---+ Introduction to Wicket Web Beans

Wicket Web Beans (WWB) is a Wicket-based component toolkit for displaying and editing POJOs that conform to the !JavaBeans specification. Web pages are automatically generated based on bean properties and certain conventions. If necessary, the layout, editability, and actions of these pages can be customized on an exception basis. In other words, the toolkit normally does what you'd expect, but when it doesn't, you can override its behavior.

At the highest-level, the wicket.contrib.webbeans.containers.BeanForm component provides rich AJAX form functionality. The Page design that the form is embedded on is left to you, but it . This allows for customized page designs. Also, this allows multiple !BeanForms may be incorporated on a single page. At your choosing, other lower-level components may be used independently of !BeanForm (e.g., !BeanGridPanel). WWB does not try to force you into a certain way of doing things, but !BeanForm makes it very convenient to implement a bean-based form if you don't want to go to a lot of extra work. You focus on the model (beans), WWB handles the user interface. 

Fields within a form are dynamically sent back to the server-side bean as they are changed, which eliminates the typical submit cycle. This makes WWB act more like a rich client application and less like a standard forms-based application. 

---+ Simple Example

Let's take a look at a simple bean from the examples:

Embed:wicket.contrib.webbeans.examples.simple.TestBean

This is a Java Bean compliant POJO. As most people know, getters start with "get" or "is" and setters start with "set". Java Beans also require a public no-argument constructor, which we have. All beans must be Serializable by Wicket convention.

This bean also implements !PropertyChangeListeners and Events. This is an optional part of the Java Beans spec. However, if you're bean implements add/removePropertyChangeListener(), !BeanForm will automatically register itself as a listener to your bean. In this example, we're going to use !PropertyChangeEvents to notify !BeanForm when dependent properties change. 

If you don't implement !PropertyChangeListeners, !BeanForm already knows if a single property changes from a change on the form. For example, setFirstName() automatically changes the input value to upper case. !BeanForm knows to refresh this field on the form because the user changed it. If you type "xyzzy" in the First Name field and tab or click away from the field, the field is sent to the bean and the field is dynamically refreshed to it's new value "XYZZY".

Before we get too deep, let's take a look at the Wicket page and HTML:

<verbatim>
	<html xmlns:wicket>
	<head>
	<wicket:head>
	    <wicket:link><link href="bean.css" type="text/css" rel="stylesheet" ></link></wicket:link>
		<title>Simple Bean Page</title>
	</wicket:head>
	</head>
	<body >
		<span wicket:id="beanForm"></span>
	</body>
	</html>
</verbatim>

Embed:wicket.contrib.webbeans.examples.simple.SimpleBeanPage

You can see this is pretty simple. There is only a single component added to the page - "beanForm" - which is an instance of wicket.contrib.webbeans.containers.BeanForm. You can see in the constructor that we create an instance of !TestBean which is passed to !BeanForm. We also create an instance of wicket.contrib.webbeans.model.BeanMetaData. !BeanMetaData reflects on the !TestBean class to derive the fields and actions for the form.

If you bring up this page in a browser (see RunningSamples), you will see something like:

WWB:/doc/wiki/images/SimpleBeanScreenShot.png

Note that "Result" is not editable because there is no setter method on the bean.

As we mentioned, !BeanMetaData represents the metadata for a bean properties and actions. By default, the metadata originates by convention:

   * Label names for properties are derived from the property name. E.g., "customerName" becomes "Customer Name"; "address2" becomes "Address 2" (or from the !JavaBean !BeanInfo "displayName").
   * Field components for the Java primitive/wrapper types, enum types, !java.util.Date and those classes deriving from it, and java.util.Lists are pre-configured.
   * All !JavaBean properties are displayed. Non-!JavaBean methods are not displayed. 
   * All fields are editable if viewOnly is false (see the !BeanMetaData constructor). Otherwise they are all view-only.
   * If a property is not writable, it is displayed view-only.
   * All fields are displayed in the order the are reflected (alphabetical order).
   * All fields are displayed in a single page. (Known as the "default tab", but the tab is hidden).

Field types are deduced from the property's Java type. The mappings from the property's Java class to the wicket.contrib.webbeans.fields.Field type is done by wicket.contrib.webbeans.model.ComponentRegistry. !ComponentRegistry has mappings for most common types and more types can be added if necessary. Also, Field types may be overridden for a specific property in the "beanprops" file, which we'll discuss later.  

---+ Customization Using "*.beanprops"

WWB is a method of programming by exception. That is, you only tell WWB to do something when its not doing what you want. Most commonly, WWB doesn't really know a good way to order fields on the page. By default, they are in alphabetical order and laid out in a three column grid.  Alphabetical order isn't typically want you want, though. To change this, you can create a "beanprops" file. This file is named like other Wicket files - it has the same based name as your Page (or component that the !BeanForm is embedded in). 

Using the Simple Example above, let's customize it. Note that we're now using wicket.contrib.webbeans.examples.simple.CustomSimpleBeanPage (we won't reiterate the trivial HTML and Page code here). This page also has a !CustomSimpleBeanPage.beanprops file, seen below:

<verbatim>
	# Customize TestBean.
	TestBean {
		cols: 1;
		props: firstName, lastName, operand1, operand2, result, -number;
	}
</verbatim>

This file tells WWB : whenever you see a !TestBean bean, layout it out in a one-column grid ("cols: 1") and display the properties ("props") in the order specified. Note that you refer to !JavaBean properties without the prefix of "get", "set", or "is" and the first character is lower case. Also in the "props" parameter, we say "-number". This tells WWB to remove the "number" property from the page. 

Note that we didn't specify a package name when we wrote "!TestBean". The package name is optional as long as the class name is not ambiguous. If !BeanMetaData matches the class name first using the simple name, then using the package and class name. Again, WWB typically matches the right class. If you have two bean classes with the same name but in different packages, you'll need to specify the package name as well.    

If you run this example, you'll see something like:

WWB:/doc/wiki/images/CustomSimpleBeanScreenShot.png

In addition to beanprops, most of the look and feel of the page can be customized via CSS.


---++ Referencing Wicket Properties Files

Let's say you don't like the generated label "Operand 1" and "Operand 2" in the previous example, or you want to be able to localize them for another language. You can fix this by adding a Wicket properties file called !CustomSimpleBeanPage.properties, such as: 

<verbatim>
operand1.Label=Enter First Value
operand1.Label=Enter Second Value
</verbatim>

And change !CustomSimpleBeanPage.beanprops as follows:
<verbatim>
	# Customize TestBean.
	TestBean {
		cols: 1;
		props: 
			firstName, lastName, 
			operand1{ label: "${operand1.Label}" }, 
			operand2{ label: "${operand2.Label}" }, 
			result, -number;
	}
</verbatim>

You can see that you can specify parameters for each bean property. This example gives operand1 and operand2 the labels "Enter First Value" and "Enter Second Value" respectively. The "${xxx}" macro expression syntax substitutes the properties file key for xxx into the value for the parameter. You can intermix text and multiple macro expressions in a single value. 

---++ Bean Property Customization

In !CustomSimpleBeanPage, the bean is editable (i.e., not view-only), hence so are all the fields by default. The "result" property is view-only by default because it has no setter. If you were to pass "viewOnly" = true to the !BeanMetaData object, all properties that were previously editable would be view-only. This is because bean properties inherit the bean's view-only setting. However, you can override this on a per-property basis. Let's say we change !CustomSimpleBeanPage.beanprops as follows:

<verbatim>
	# Customize TestBean.
	TestBean {
		cols: 1;
		props: 
			firstName, 
			lastName{ label: "Last Name (informational)"; viewOnly: true }, 
			operand1{ label: "${operand1.Label}" }, 
			operand2{ label: "${operand2.Label}" }, 
			result, -number;
	}
</verbatim>

This causes the lastName property to get a different label and be view-only.

---+ Actions

It's simple to add actions to your form. Here's the code for wicket.contrib.webbeans.examples.actions.ActionBeanPage:

Embed:wicket.contrib.webbeans.examples.actions.ActionBeanPage

And here's ActionBeanPage.beanprops:

<verbatim>
	# Actions Example
	TestBean {
		actions: save, cancel, clearLastName;
		
		props: firstName, lastName, action.clearLastName,
			operand1, operand2, result, -number;
	}
</verbatim>

Note the "actions" parameter. This defines the actions available from your Page (or whatever component the form is embedded in). The action name corresponds precisely to the method name in the Page. Every action method must have the following method signature:

<verbatim>
    public void actionName(AjaxRequestTarget target, Form form, Object bean) 
    { 
        ...
    }
</verbatim>

The target parameter normally null. It is only non-null if you specify the "ajax: true" parameter to the action. The Wicket Form is always passed in "form" and the bean that the action applies to is in "bean".  

This configuration yeilds the following page:
WWB:/doc/wiki/images/ActionBeanScreenshot.png

Since the save and cancel actions are not referenced anywhere else in the beanprops file, WWB assumes that they are global actions for the Page. However, the clearLastName action is referenced in the "props" parameter. It is referenced using the "action." prefix to distinguish it from a regular bean property. In this example, we placed the action near the lastName property since they are related. When you click the Clear Last Name button, the last name field will clear out.

---+ Tabs

There may be many times when you have more information for a form than can fit on a single page. One method of splitting up this information is to group it into tabs. Of course, WWB makes tabs easy too. Let's look at wicket.contrib.webbeans.examples.tabs.TabBeanPage. The Java code is exactly the same as !ActionBeanPage, but the beanprops are a little different:

<verbatim>
	# Tabs Example
	TestBean {
		actions: save, cancel, clearLastName;
		
		props: -number;
		
		tabs: 
			name { props: firstName, lastName, action.clearLastName },
			calculator { props: operand1, operand2, result }; 
	}
</verbatim>

Here we just use !TestBean "props" to specify the properties we don't want. "name" and "calculator" specify the tab groupings. We specify a "props" parameter for each tab to say which properties fall on which tab, and in what order. The result looks like:  

WWB:/doc/wiki/images/TabBeanScreenshot.png

Alternately we could configure all of the properties in !TestBean's "props" if we wanted. By default all properties that weren't specified for a tab fall in the first tab, so we could have said: 
 
<verbatim>
	# Tabs Example
	TestBean {
		actions: save, cancel, clearLastName;
		
		props: firstName, lastName, action.clearLastName, -number;
		
		tabs: 
			name, calculator { props: operand1, operand2, result }; 
	}
</verbatim>

and gotten the same result.

---+ Bean Contexts

WWB contexts allow you to develop different use cases for the same form and page code. For example, in a simple CRUD application, you might want to allow the user to enter all fields on the add of a record, simple view the record without changing anything, and only allow certain fields to be changed on update. Let's take a look at wicket.contrib.webbeans.examples.contexts.ContextBeanPage:

Embed:wicket.contrib.webbeans.examples.contexts.ContextBeanPage
 
Note that we pass "view" to the !BeanMetaData constructor. This is the context (or use case) that we want. Of course, you can dynamically come up with this context in the Page constructor depending on parameters passed, etc.
 
Here's the beanprops file:

<verbatim>
	# Context Example
	TestBean {
		props: firstName, lastName, EMPTY,
			operand1, operand2, result, -number;
	}
	
	TestBean[view] {
		viewOnly: true;
	}
	
	TestBean[limitedEdit extends view] {
		props: firstName{ viewOnly: false };
	}
</verbatim>

If you run this page from the examples, you will see that all fields are view-only. When we specify "!TestBean[view]", it tells WWB to extend the default definition for !TestBean. The "view" context inherits all of the parameters from the default specification and overrides the bean's "viewOnly" parameter to be true. This causes all of the fields to be view-only.

If you change the following line in !ContextBeanPage, from "view" to "limitedEdit", WWB uses the third definition in the beanprops file:
  
<verbatim>
        BeanMetaData meta = new BeanMetaData(bean.getClass(), "limitedEdit", this, null, false);
</verbatim>

This cause just the firstName property to become editable.  The "[limitedEdit extends view]" tells WWB to extend the "view" context, which in turn extends the default context. 

---+ Nested Beans

---+ Tables

= beanprops syntax =
= Component Parameter Reference = 

= Details =

{{{
<verbatim>
# Default specification/context for bean TestBean. Package name is optional.
# Standard parameters are: label, actions, props, tabs, displayed, viewOnly.
TestBean {
	# Standard Bean-level parameters are: label, actions, props, tabs, displayed, viewOnly. In addition,
	# you may specify Bean container-specific ones (e.g., BeanGridPanel allows "columns").
	
	# $(property-name) to reference a Wicket property file property (i.e., Localizer). Can be used anywhere in a value and
	# in any kind of value.  Double quotes may be used to embed whitespace in values.
	label: "My ${TestBean.title} Title";   

	# Defines the actions available for the bean.
	# This is a list of action methods available on the Wicket Page that the bean
 	# is embedded in. These methods must be public and have the following signature:
 	#     public void <i>doSomething</i>(AjaxRequestTarget target, Form form, Object bean)
 	# The target parameter may be null for non-Ajax requests. 
 	# These can be referenced as "action.{action-method-name}" in props. 
 	# Actions not included in the "props" parameter are considered to be "global" actions
	# that appear outside of any tabs.
		
	actions: save,cancel,doIt,addRow;

	# This is a list of properties that may have parameters and are presented on the page in the order specified below. 
	# Any other properties not specified are presented at the end of the page. 
	# Properties beginning with "action." refer to actions defined in "actions:" above, not to bean properties.
	# If the property begins with "-", it is not displayed.
	# The "EMPTY" pseudo-property name can be used to provide an empty field (e.g., a blank cell in a grid). 
	# Configuration may be specified for each property within "{}". Standard configuration parameters are:
	#   label, labelImage, viewOnly, fieldType (overrides the Field used), elementType. 
	# For Collections, elementType is the type of the elements
 	# contained within the collection. If this is not specified and the collection is not 
 	# null and not empty, the elementType is detected from the first element of the collection.
	# In addition, you may specify Bean container and Field-level specific parameters (e.g., BeanGridPanel allows "colspan").
	# For action parameters, see BeanActionButton.
	props: 
		action.save{colspan: 3},
		firstName,
		lastName,
		EMPTY,
		activePrimitive,
		color,
		# Note that only the base class name for fieldType is specified, not the package (wicket.contrib.beancomponents.fields) which is optional.
		# This class must be in the ComponentRegistry for this to work. Otherwise, you can explicitly specify the package name. 
		inlineBean{fieldType: BeanInlineField; colspan: 3},
		dateTimestamp,
		blockBean{fieldType: BeanGridField; colspan: 3},
		testBean2{colspan: 3},
		popupBean{colspan: 3},
		-subComponent;  # Explicitly hides subComponent.

	# Tabs are optional. Only specify the properties not on the default tab. 
	# Each tab can define parameters. Standard parameters are: label, props.
	tabs: 
		nameInfo, # Default tab: no props specified, so it gets all of the bean props not used in other tabs.
		miscInfo {
			label: "${MiscInfo.title}";
			props:
				gender,
				EMPTY,  # Empty cell/spacer.
				age,
				operand1,
				operand2,
				result{viewOnly: true},
				# Note that only the base class name for elementType is specified, not the package, which is optional.
				# This class must be in the same package as the bean for this to work. Otherwise, you can explicitly specify the package name. 
				palette{elementType: TestBean$ColorEnum},
				palette2{elementType: TestBean$ColorEnum; viewOnly: true},
				description{fieldType: TextAreaField; rows: 5};
		}, 
		listOfBeans {
			props: 
				action.addRow{colspan: 3}, 
				beans{viewOnly: true; rows: 20};
		};
}

# [] specifies a specific context (e.g., a use-case). This one extends the default context implicitly.
TestBean[view] {
	viewOnly: true;
}

TestBean[popupView extends view] {
	props: 
		-color,		# Remove the color property from the default list. 
		lastName{viewOnly: false}; # Change the parameter of lastName
}

TestBean2 {
	actions: deleteRow;
	props: 
		action.deleteRow{labelImage: "remove.gif"},
		selected{label: X},
		firstName{viewOnly: false},
		lastName;
}
</verbatim>
}}}


= CSS Guide =






